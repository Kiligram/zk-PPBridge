// SPDX-License-Identifier: MIT

/*
    Contract is a conjunction of several Tornado Cash contracts available on https://github.com/tornadocash/tornado-core/tree/master/contracts
    Functions reclaim and submitRoot are written by myself. 

    Smart contract currently containes 'relyer' functionality from the original Tornado Cash implementation.
    Such a relayer is needed in cases when the user does not have sufficient assets in their wallet to facilitate the withdrawal of the deposit. 
    In such situations, the relayer acts on behalf of the user to initiate the withdrawal, deducting a portion of the deposit to cover the transaction fees (gas costs).
    Such an approach allows for withdrawals to be made to completely new wallets that have no transaction history, ensuring enhanced privacy.
    Even though the smart contract is ready to be used by relyer, the existing Tornado Cash relayer must be modified in order to work with this solution.
*/

pragma solidity ^0.7.0;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

interface IVerifier {
    function verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool);
}

contract DestinationWrappedETH is ERC20, ReentrancyGuard {

    IVerifier public immutable verifier;
    address bridge;
    uint256 public denomination;
    mapping(bytes32 => bool) public nullifierHashes;

    // roots could be bytes32[size], but using mappings makes it cheaper because
    // it removes index range check on every interaction
    mapping(uint256 => bytes32) public roots;

    // The root history is needed because the root changes with every new deposit, 
    // which means that the root generated by the user can become outdated by the time it is provided for withdrawal.
    uint32 public constant ROOT_HISTORY_SIZE = 30;
    uint32 public currentRootIndex = 0;

    event Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee);
    event Reclaim(address recipient, uint256 amount);

    /**
        @dev The constructor
        @param _bridge the address of bridge wallet
        @param _verifier the address of SNARK verifier contract
        @param _denomination transfer amount for each deposit
    */
    constructor(
        address _bridge,
        IVerifier _verifier,
        uint256 _denomination
    ) ERC20("PrivacyPreservingWrappedETH", "PPWETH") {
        require(_denomination > 0, "denomination should be greater than 0");
        bridge = _bridge;
        verifier = _verifier;
        denomination = _denomination;
    }

    modifier onlyBridge() {
        require(
            bridge == msg.sender,
            "This method can be called by bridge only!"
        );
        _;
    }

    /// @dev function sets the new Merkle root and can be called only by bridge (relayer) and 
    function submitRoot(bytes32 root) external onlyBridge {
        uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;
        currentRootIndex = newRootIndex;
        roots[newRootIndex] = root;
    }

    /// @dev function burns the caller's tokens and emmits Reclaim event
    function reclaim(address recipient, uint256 amount) external nonReentrant {
        _burn(msg.sender, amount);
        emit Reclaim(recipient, amount);
    }

    /**
        @dev Withdraw a deposit made on origin chain. 
        @param _proof zkSNARK proof
        @param _root merkle root of all deposits in the contract
        @param _nullifierHash hash of unique deposit nullifier to prevent double spends
        @param _recipient recipient of funds
        @param _relayer address of relayer
        @param _fee optional argument representing the fee that goes to the transaction sender (usually a relay)
        @param _refund optional argument representing the ETH value that goes to the recipient along with the deposited tokens
    */
    function withdraw(
        bytes calldata _proof,
        bytes32 _root,
        bytes32 _nullifierHash,
        address payable _recipient,
        address payable _relayer,
        uint256 _fee,
        uint256 _refund
    ) external payable nonReentrant {
        require(_fee <= denomination, "Fee exceeds transfer value");
        require(!nullifierHashes[_nullifierHash], "The note has been already spent");
        require(isKnownRoot(_root), "Cannot find your merkle root"); // Make sure to use a recent one
        require(
        verifier.verifyProof(
            _proof,
            [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _fee, _refund]
        ),
        "Invalid withdraw proof"
        );

        // remember provided nullifier hash, so that the same deposit would not be withdrawn for the second time
        nullifierHashes[_nullifierHash] = true;
        _processWithdraw(_recipient, _relayer, _fee, _refund);
        emit Withdrawal(_recipient, _nullifierHash, _relayer, _fee);
    }

    /**
        @dev Auxiliary function that performs the withdrawal
    */
    function _processWithdraw(
        address payable _recipient,
        address payable _relayer,
        uint256 _fee,
        uint256 _refund
    ) internal {
        require(msg.value == _refund, "Incorrect refund amount received by the contract");

        _mint(_recipient, denomination - _fee);

        // if the relayer was used, send it the transaction fee as a compensation 
        if (_fee > 0) {
            _mint(_relayer, _fee);
        }

        // refund is sent to the recipient's address in case their balance is empty, 
        // so that they could use this refund to pay for gas when moving the tokens further
        if (_refund > 0) {
            (bool success, ) = _recipient.call{ value: _refund }("");
            if (!success) {
                // return _refund back to the relayer in case it could not be sent to recipient
                _relayer.transfer(_refund);
            }
        }
    }

    /**
        @dev Check whether the deposit was withdrawn
    */
    function isSpent(bytes32 _nullifierHash) public view returns (bool) {
        return nullifierHashes[_nullifierHash];
    }

    /**
        @dev Check whether the root is present in the root history
    */
    function isKnownRoot(bytes32 _root) public view returns (bool) {
        if (_root == 0) {
            return false;
        }
        uint32 _currentRootIndex = currentRootIndex;
        uint32 i = _currentRootIndex;
        do {
            if (_root == roots[i]) {
                return true;
            }
            if (i == 0) {
                i = ROOT_HISTORY_SIZE;
            }
            i--;
        } while (i != _currentRootIndex);
        return false;
    }

    /**
        @dev Returns the last root
    */
    function getLastRoot() public view returns (bytes32) {
        return roots[currentRootIndex];
    }

}